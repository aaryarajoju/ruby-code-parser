#!/usr/bin/env ruby
# frozen_string_literal: true

# CLI tool for analyzing pull requests for design principle violations
#
# Usage:
#   ./bin/analyze_pr <PR_URL>                    # Analyze a single PR
#   ./bin/analyze_pr --csv <file.csv>            # Analyze PRs from CSV
#   ./bin/analyze_pr --csv <file.csv> --filter "term"  # Filter CSV rows
#
# Options:
#   --csv FILE        Read PR URLs from a CSV file
#   --column COL      CSV column containing PR links (default: "links")
#   --filter TERM     Only process rows containing this term
#   --output DIR      Output directory for reports (default: "reports")
#   --format FMT      Output formats: json,md,html (default: all)
#   --config FILE     Config file path (YAML or JSON)
#   --verbose         Enable verbose output
#   --help            Show this help

require 'bundler/setup'
require 'optparse'

# Explicit CSV require for Ruby 3.4+ compatibility
begin
  require 'csv'
rescue LoadError
  # csv gem not installed
end

# Load the library
require_relative '../lib/ruby_code_parser'
require_relative '../lib/ruby_code_parser/config'
require_relative '../lib/ruby_code_parser/services/github_service'
require_relative '../lib/ruby_code_parser/services/diff_analyzer'
require_relative '../lib/ruby_code_parser/services/pull_request_analyzer'
require_relative '../lib/ruby_code_parser/reporters/pr_report_formatter'
require_relative '../lib/ruby_code_parser/reporters/pr_report_service'

class PRAnalyzerCLI
  def initialize
    @options = {
      output_dir: 'reports',
      formats: %w[json md html],
      column: 'links',
      verbose: true,
      config_file: nil,
      filter: nil,
      csv_file: nil,
      report_only_changed: true  # Only report violations in changed code
    }
  end

  def run(args)
    parse_options(args)

    if @options[:help]
      puts option_parser
      return 0
    end

    if @options[:csv_file]
      run_csv_mode
    elsif args.any?
      run_single_pr_mode(args.first)
    else
      puts "Error: Please provide a PR URL or use --csv option"
      puts option_parser
      return 1
    end

    0
  rescue StandardError => e
    puts "Error: #{e.message}"
    puts e.backtrace.first(5).join("\n") if @options[:verbose]
    1
  end

  private

  def parse_options(args)
    option_parser.parse!(args)
  end

  def option_parser
    @option_parser ||= OptionParser.new do |opts|
      opts.banner = "Usage: #{$PROGRAM_NAME} [options] [PR_URL]"

      opts.separator ""
      opts.separator "Options:"

      opts.on("--csv FILE", "Read PR URLs from CSV file") do |file|
        @options[:csv_file] = file
      end

      opts.on("--column COL", "CSV column containing PR links (default: links)") do |col|
        @options[:column] = col
      end

      opts.on("--filter TERM", "Only process rows containing this term") do |term|
        @options[:filter] = term
      end

      opts.on("--output DIR", "Output directory for reports") do |dir|
        @options[:output_dir] = dir
      end

      opts.on("--format FORMATS", "Output formats: json,md,html (comma-separated)") do |formats|
        @options[:formats] = formats.split(',').map(&:strip)
      end

      opts.on("--config FILE", "Config file path (YAML or JSON)") do |file|
        @options[:config_file] = file
      end

      opts.on("--[no-]verbose", "Enable verbose output") do |v|
        @options[:verbose] = v
      end

      opts.on("--[no-]changed-only", "Only report violations in changed code (default: true)") do |v|
        @options[:report_only_changed] = v
      end

      opts.on("-h", "--help", "Show this help") do
        @options[:help] = true
      end
    end
  end

  def run_single_pr_mode(pr_url)
    puts "Analyzing PR: #{pr_url}" if @options[:verbose]

    analyzer = build_analyzer
    report_service = build_report_service

    result = analyzer.analyze_by_url(pr_url)
    report_service.generate(result, output_dir: @options[:output_dir])
  end

  def run_csv_mode
    unless File.exist?(@options[:csv_file])
      raise "CSV file not found: #{@options[:csv_file]}"
    end

    puts "Processing CSV: #{@options[:csv_file]}" if @options[:verbose]
    if @options[:filter]
      puts "Filtering for: #{@options[:filter]}" if @options[:verbose]
    end

    analyzer = build_analyzer
    report_service = build_report_service
    all_results = []

    CSV.foreach(@options[:csv_file], headers: true) do |row|
      raw_text = row[@options[:column]].to_s

      # Apply filter if specified
      next if @options[:filter] && !raw_text.include?(@options[:filter])

      # Extract PR URLs from the row
      pr_urls = RubyCodeParser::Services::GitHubService.extract_pr_urls(raw_text)
      next if pr_urls.empty?

      puts "\n--- Processing Row ---" if @options[:verbose]

      pr_urls.each do |pr_info|
        begin
          puts "  PR: #{pr_info[:repo]}##{pr_info[:pr_number]}" if @options[:verbose]

          result = analyzer.analyze(
            repo: pr_info[:repo],
            pr_number: pr_info[:pr_number]
          )

          report_service.generate(result, output_dir: @options[:output_dir])
          all_results << result

        rescue StandardError => e
          puts "  [ERROR] #{e.message}" if @options[:verbose]
        end
      end
    end

    # Generate combined report
    if all_results.any?
      combined_path = File.join(@options[:output_dir], 'combined_report.json')
      report_service.generate_combined(all_results, output_path: combined_path)
    end

    puts "\nProcessed #{all_results.count} PRs" if @options[:verbose]
  end

  def build_analyzer
    config = load_config

    github_service = RubyCodeParser::Services::GitHubService.new(
      access_token: config[:github, :token]
    )

    diff_analyzer = RubyCodeParser::Services::DiffAnalyzer.new
    facade = RubyCodeParser::Facade.new

    RubyCodeParser::Services::PullRequestAnalyzer.new(
      github_service: github_service,
      diff_analyzer: diff_analyzer,
      facade: facade,
      config: {
        temp_dir: File.join(Dir.pwd, 'temp_downloads'),
        cleanup_temp: true,
        verbose: @options[:verbose],
        report_only_changed: @options[:report_only_changed]
      }
    )
  end

  def build_report_service
    RubyCodeParser::Reporters::PRReportService.new(
      config: {
        output_dir: @options[:output_dir],
        formats: @options[:formats],
        verbose: @options[:verbose]
      }
    )
  end

  def load_config
    RubyCodeParser::Config.new(config_file: @options[:config_file])
  end
end

# Run the CLI
exit PRAnalyzerCLI.new.run(ARGV)

